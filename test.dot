0 [ label="PHILOSOPHY"];
6 [ label="What, not how"];
0 -> 6;
7 [ label="Code reifies understanding"];
0 -> 7;
8 [ label="Composition"];
0 -> 8;
9 [ label="Understanding before implementation"];
0 -> 9;
10  [ label="Purity"];
0 -> 10;
11  [ label="Applications want to be libraries"];
0 -> 11;
90  [ label="If it compiles, it works"];
0 -> 90;
117 [ label="Open world assumption"];
0 -> 117;
1 [ label="CONCEPTS"];
16  [ label="Syntax and Semantics"];
1 -> 16;
18  [ label="Reusable Vocabulary"];
1 -> 18;
19  [ label="The best abstractions already exist"];
1 -> 19;
20  [ label="Introduction and Elimination"];
1 -> 20;
21  [ label="Types and Values"];
1 -> 21;
35  [ label="Illegal states are unrepresentable"];
1 -> 35;
36  [ label="Separate interface and implementation"];
1 -> 36;
37  [ label="Computing is not about computers"];
1 -> 37;
40  [ label="Pure over effectful"];
1 -> 40;
41  [ label="Parallel over sequential"];
1 -> 41;
42  [ label="Laws"];
1 -> 42;
55  [ label="Functions"];
1 -> 55;
57  [ label="Effects"];
1 -> 57;
116 [ label="Totality"];
1 -> 116;
2 [ label="THEORY"];
33  [ label="Common Typeclasses"];
2 -> 33;
34  [ label="Yoneda Embeddings"];
2 -> 34;
56  [ label="Data dependency"];
2 -> 56;
89  [ label="Infinite Data Structures"];
2 -> 89;
91  [ label="Isomorphisms"];
2 -> 91;
95  [ label="Partial functions"];
2 -> 95;
105 [ label="Quantifiers"];
2 -> 105;
113 [ label="Initial encodings"];
2 -> 113;
114 [ label="Final encodings"];
2 -> 114;
3 [ label="TOOLS"];
43  [ label="Combinator libraries"];
3 -> 43;
53  [ label="Modeling with Types"];
3 -> 53;
54  [ label="Structural programming"];
3 -> 54;
63  [ label="Custom control flow"];
3 -> 63;
64  [ label="Higher order functions"];
3 -> 64;
66  [ label="Type variables"];
3 -> 66;
72  [ label="Recursion Schemes"];
3 -> 72;
75  [ label="Nonregular Recursion"];
3 -> 75;
81  [ label="Smart constructors"];
3 -> 81;
4 [ label="TRICKS"];
4 -> 34;
62  [ label="Asymptotic Improvement"];
4 -> 62;
68  [ label="Structural diffing"];
4 -> 68;
69  [ label="Copy on write"];
4 -> 69;
71  [ label="CPS"];
4 -> 71;
73  [ label="Acccumulating caches"];
4 -> 73;
87  [ label="Precomposition"];
4 -> 87;
119 [ label="Trampolining"];
4 -> 119;
5 [ label="PROBLEMS"];
82  [ label="Parsers"];
5 -> 82;
88  [ label="Structural problems"];
5 -> 88;
22  [ label="Of functions"];
8 -> 22;
23  [ label="Of implementations"];
8 -> 23;
24  [ label="Of understanding"];
8 -> 24;
25  [ label="Of correctness"];
8 -> 25;
10 -> 40;
10 -> 57;
10 -> 68;
70  [ label="Sharing"];
10 -> 70;
59  [ label="Monads are overused"];
11 -> 59;
12  [ label="DESIDERATA"];
13  [ label="Correctness"];
12 -> 13;
14  [ label="Flexibility"];
12 -> 14;
15  [ label="Empathy"];
12 -> 15;
39  [ label="Simplicity"];
12 -> 39;
13 -> 25;
13 -> 35;
13 -> 39;
13 -> 42;
14 -> 117;
15 -> 35;
15 -> 42;
17  [ label="Denotations"];
16 -> 17;
16 -> 36;
17 -> 24;
18 -> 19;
18 -> 33;
67  [ label="Bend it to fit the abstraction"];
18 -> 67;
19 -> 33;
76  [ label="Common Iterations"];
19 -> 76;
22 -> 119;
23 -> 43;
24 -> 43;
25 -> 43;
26  [ label="Monoids"];
26 -> 73;
101 [ label="Validation"];
26 -> 101;
110 [ label="Function monoids"];
26 -> 110;
27  [ label="Functors"];
28  [ label="Applicatives"];
28 -> 101;
29  [ label="Selectives"];
30  [ label="Monads"];
30 -> 59;
31  [ label="Semilattices"];
32  [ label="Comonads"];
33 -> 26;
33 -> 27;
33 -> 28;
33 -> 29;
33 -> 30;
33 -> 31;
33 -> 32;
100 [ label="Alternatives"];
33 -> 100;
60  [ label="Dlists"];
34 -> 60;
61  [ label="Codensity"];
34 -> 61;
52  [ label="Well-typed"];
35 -> 52;
35 -> 66;
35 -> 81;
35 -> 90;
35 -> 116;
38  [ label="Thinking about performance gets in the way"];
37 -> 38;
38 -> 70;
86  [ label="Derive performance from the problem"];
38 -> 86;
39 -> 14;
39 -> 90;
40 -> 41;
41 -> 28;
41 -> 30;
42 -> 18;
85  [ label="Algebraic properties"];
42 -> 85;
43 -> 82;
44  [ label="Types"];
45  [ label="U1"];
44 -> 45;
46  [ label="V1"];
44 -> 46;
47  [ label="Products"];
44 -> 47;
48  [ label="Coproducts"];
44 -> 48;
49  [ label="Mu"];
44 -> 49;
50  [ label="Nu"];
44 -> 50;
51  [ label="Function Types"];
44 -> 51;
44 -> 54;
65  [ label="I1"];
44 -> 65;
97  [ label="Common types"];
44 -> 97;
109 [ label="Compose"];
44 -> 109;
120 [ label="ADTS"];
44 -> 120;
121 [ label="GADTs"];
44 -> 121;
103 [ label="Vs union types"];
48 -> 103;
52 -> 44;
53 -> 44;
53 -> 81;
102 [ label="Newtypes over aliases"];
53 -> 102;
54 -> 72;
55 -> 22;
55 -> 95;
56 -> 41;
56 -> 59;
57 -> 28;
57 -> 30;
57 -> 59;
58  [ label="ANTIPATTERNS"];
58 -> 59;
58 -> 95;
58 -> 103;
107 [ label="Unsafe coerce the existential"];
58 -> 107;
108 [ label="Existentials as arguments"];
58 -> 108;
111 [ label="Endos"];
60 -> 111;
62 -> 34;
64 -> 63;
64 -> 87;
70 -> 69;
71 -> 119;
83  [ label="Folds"];
72 -> 83;
84  [ label="Unfolds"];
72 -> 84;
74  [ label="Finger trees"];
73 -> 74;
80  [ label="Diagram Envelopes"];
73 -> 80;
75 -> 74;
75 -> 87;
76 -> 72;
77  [ label="Traversals"];
76 -> 77;
78  [ label="Maps"];
76 -> 78;
79  [ label="FoldMaps"];
76 -> 79;
77 -> 28;
78 -> 27;
79 -> 26;
85 -> 86;
86 -> 68;
88 -> 54;
89 -> 32;
92  [ label="There and back again"];
91 -> 92;
93  [ label="TESTING"];
94  [ label="Property tests"];
93 -> 94;
94 -> 42;
94 -> 85;
94 -> 92;
96  [ label="Maybe"];
96 -> 95;
97 -> 96;
98  [ label="Either"];
97 -> 98;
99  [ label="Lists"];
97 -> 99;
98 -> 95;
100 -> 96;
100 -> 98;
100 -> 99;
104 [ label="Existentializing"];
104 -> 107;
104 -> 108;
105 -> 104;
106 [ label="Forall"];
105 -> 106;
109 -> 27;
109 -> 28;
109 -> 29;
110 -> 111;
112 [ label="Aps"];
110 -> 112;
113 -> 61;
114 -> 71;
116 -> 53;
116 -> 55;
118 [ label="Only local coherence"];
117 -> 118;
119 -> 30;
